module Zeta where

import Data.Number.IReal

{- 

Koecher's formula for approximating zeta(5), i.e. sum (map (recip . (^5)) [1..]).
Checked by comparison to A013663 in The Online Encyclopedia of Integer Sequences 

See e.g. 
Borwein, Bradley, Crandall: Computational strategies for the Riemann zeta function, 
Journal of Computational and Applied Mathematics 121 (2000) 247-296.
(in particular pages 271-272).

-}

-- List of binomial coefficients bin(2k,k) for k=1,2,3...
bins :: [Integer]
bins = scanl f 2 [1..]
   where f c n = c `div` (n+1) * 2*(2*n+1)

-- Partial sums for zeta(2)
z2s :: Fractional a => [a]
z2s = scanl g 0 [1..]
   where g s n = s + recip (fromInteger (n^2))

-- Prints zeta(5) to d decimals. d should be at most a few thousand.
z5s d = scale (sum (zipWith3 h [1..nmax] z2s bins)) (-1) ? d
    where nmax = floor(5*fromIntegral d/3) + 1
          h n a b = (-1)^(mod n 2) * (5*a - scale (recip (fromInteger (n^2))) 2)/(fromInteger (b * n^3))

{-

It is interesting that using the left-folding summation function sum above is crucial; both 
bsum and isumN', as tried below, give exponential behaviour. In general, when terms to be summed
are generated by scanl, one should consider using sum, for a more favourable computation order.

z5b d =  scale (bsum (zipWith3 h [1..nmax] z2s bins)) (-1) ? d
    where nmax = floor(5*fromIntegral d/3) + 1
          h n a b = (-1)^(mod n 2)*(5*a - scale (recip (fromInteger (n^2))) 2)/(fromInteger (b * n^3))


z5i d = scale (isumN' nmax (zipWith3 h [1..nmax] z2s bins)) (-1) ? d
    where nmax = floor(5*fromIntegral d/3) + 1
          h n a b = (-1)^(mod n 2)*(5*a - scale (recip (fromInteger (n^2))) 2)/(fromInteger (b * n^3))

-}